---
title: "Introduction to filter DataFrame Rows "
description: |
  Using best practices, you can learn how to cut the data  and filter specific rows/observations.
author:
  - name: "Parnian Jahangiri Rad"
    occupation: "Data science intern"
    affiliation: "DataMotto"
    url: "https://www.linkedin.com/in/parnian-jahangiri-rad-4603611b4"
    img: "Parnian-Jahangiri-Rad.jpg"
    lang: "r , python"
tech:
  - lang: r
    pkgs: ["dplyr"]
  - lang: python
    pkgs: ["pandas"]
date:
  created: "2021-07-15"
  last_updated: "2021-07-15"
categories: ["Wrangling"]
applications: ["General"]
cover_image: NULL
slug: "introduction-to-filter-dataframe-rows-"
output: DataMotto::Dotto
---

```{r DataMotto, echo=FALSE}
DataMotto::use_Dotto()
```

<!-- Dot 1, lang: r ------------------------------------------------>

```{block, Dot = 1, part = "Instruction", lang = "r"}
In this dot,we are using dataset `penguins_raw` from `palmerpenguins` package.
`palmerpenguins` contains 2 datasets,`penguins` and `penguins_raw` which is about 344 penguins.  
You can install this package with :  
install.packages("palmerpenguins")  
Access `penguins_raw` dataset with :  
  
   library(palmerpenguins)  
   data_penguin <- penguins_raw
  
This dataset includes nesting observations, penguin size data, and isotope measurements from blood samples for adult Adélie, Chinstrap, and Gentoo penguins.It has 344 rows and 17 columns.However , we only need columns:  
  `individual_id`  
  `date_egg`  
  `body-mass-g`  
  `sex`
  
Here, we use `janitor` package ,`clean_names()` function to clean data frame names.
`clean_name()` works in `%>%` (pipe).  
```

<!-- Dot 1, lang: Python ------------------------------------------------>
```{block, Dot = 1, part = "Instruction", lang = "python"}
In this dot,we are using dataset `penguins_raw` ,that can be downloded from
[here](site address).
This dataset includes nesting observations, penguin size data, and isotope measurements from blood samples for adult Adélie, Chinstrap, and Gentoo penguins.It has 344 rows and 17 columns.  
However , we only need columns:  
`individual_id`    
`date_egg`    
`body-mass-g`    
`sex`    

Here, we use `janitor` package ,`clean_names()` function to clean dataframe names.
```

```{r, Dot = 1, part = "Code", echo = T, eval = F, }
library(dplyr)
library(palmerpenguins)
library(janitor)
penguins_data <- penguins_raw %>%
  clean_names() %>%
  select(individual_id , date_egg , body_mass_g , sex)
```

```{python, Dot = 1, part = "Code", echo = T, eval = F, }
import pandas as pd
import janitor

penguins_raw = pd.read_csv("/home/parnian/Documents/sprint3/penguins_raw.csv")
penguine_data = penguins_raw.clean_names()
penguins_data = penguine_data[["individual_id" , "date_egg" ,"body_mass_g_" , "sex" ]]
```



```{r, Dot = 1, part = "Result", echo = F, eval = T}
library(dplyr)
library(palmerpenguins)
library(janitor)
library(kableExtra)
penguins_data <- penguins_raw %>%
  clean_names() %>% 
  select(individual_id , date_egg , body_mass_g , sex)
penguins_data %>%
  head(5) %>% 
  kbl(caption = "first 5 records of penguins_data") %>%
  kable_material(c("striped", "hover"))
```

```{python, Dot = 1, part = "Result", echo = F, eval = T}
import pandas as pd
import janitor

penguins_raw = pd.read_csv("/home/parnian/Documents/sprint3/penguins_raw.csv")
penguine_data = penguins_raw.clean_names()
penguins_data = penguine_data[["individual_id" , "date_egg" ,"body_mass_g_" , "sex" ]]
penguins_data
```

<!-- Dot 2, lang: r ------------------------------------------------>
```{block, Dot = 2, part = "Instruction", lang = "r"}
`filter()` function, from `dplyr` package, helps us to filter data frame rows
based on conditions.  
 Useful filter functions:
   `==` , `<` , `>` , etc.  
   `&` , `|` , `!` , `xor()`  
   `is.na()`  
   `between()` , `near()`  

`filter()` (and other `dplyr` functions) work with pipes `%>%` and expect tidy data.   
In tidy data:  
* Each variable is in its own column.  
* Each observation, or case, is in its own row.  
`%>%` makes code shorter and more readable. It also makes debugging much easier.
for example , `x %>% f(y)` is equivalent to `f(x, y)`.
```
<!-- Dot 2, lang: python ------------------------------------------------>
```{block, Dot = 2, part = "Instruction", lang = "python"}
We can use logical operators like `==` , `<` and `>` on columns to filter
dataframe rows.  
For examle , `df[df.col1 == 3800]` will select rows with `col1` = 3800.  
```

```{r, Dot = 2, part = "Code", echo = T, eval = F, }
data <- penguins_data %>%
  filter(body_mass_g == 3800)

MAX_BODY_MASS <- penguins_data %>%
  filter(!is.na(body_mass_g)) %>%
  filter(body_mass_g == max(body_mass_g))
```

```{python, Dot = 2, part = "Code", echo = T, eval = F, }
penguins_data [ penguins_data.body_mass_g_ ==  3800 ]

penguins_data [ penguins_data.body_mass_g_ ==  max(penguins_data.body_mass_g_)]
```

```{r, Dot = 2, part = "Result", echo = F, eval = T}
penguin_body_3800 <- penguins_data %>%
  filter(body_mass_g == 3800)

MAX_BODY_MASS <- penguins_data %>%
  filter(!is.na(body_mass_g)) %>%
  filter(body_mass_g == max(body_mass_g))

penguin_body_3800 %>% 
   kbl(caption = "penguins  with body_mass = 3800 ") %>%
   kable_material(c("striped", "hover"))

MAX_BODY_MASS %>%
   kbl(caption = "penguin(s) with maximum body_mass") %>%
   kable_material(c("striped", "hover"))
```

```{python, Dot = 2, part = "Result", echo = F, eval = T}
penguins_data [ penguins_data.body_mass_g_ ==  3800 ]

penguins_data [ penguins_data.body_mass_g_ ==  max(penguins_data.body_mass_g_)]
```

<!-- Dot 3, lang: r ------------------------------------------------>
```{block, Dot = 3, part = "Instruction", lang = "r"}
We can use `==` , `<` and  `>` operators with strings as well.  
For example , `A == "ABC"` checks whether string A is equal to `"ABC"`,
or `A < "ABC"` checks if string A comes before "ABC" (in alphabetical order).  
  
We can also filter data frame rows using Dates.  
For example , `penguins_data %>% filter(Date_Egg < "2007-11-10")` filters
rows with Date_Egg before 2007-11-10.
```

<!-- Dot 3, lang: python ------------------------------------------------>
```{block, Dot = 3, part = "Instruction", lang = "python"}
We can also use logical operators on strings.  
For example, `penguins_data [penguins_data.individual_id < "N1A2" ]` will 
select strings  that come before `N1A2` in alphabetical order.  
  
We can also filter data frame rows using Dates.   
For example , `penguins_data [penguins_data.date_egg < "2007-11-10" ]` will 
select rows with date_egg before '2007-11-10'.
```

```{r, Dot = 3, part = "Code", echo = T, eval = F, }
N1A2_penguin <- penguins_data %>%
  filter(individual_id == "N1A2")

penguin_2007_11_10 <- penguins_data %>%
  filter(date_egg < "2007-11-10")
```

```{python, Dot = 3, part = "Code", echo = T, eval = F, }
penguins_data [penguins_data.individual_id == "N1A2" ]

penguins_data [penguins_data.date_egg < "2007-11-10" ]
```

```{r, Dot = 3, part = "Result", echo = F, eval = T}
N1A2_penguin <- penguins_data %>%
  filter(individual_id == "N1A2")
N1A2_penguin %>%
   kbl(caption = "penguin with individual_id = N1A2") %>%
   kable_material(c("striped", "hover"))

penguin_2007_11_10 <- penguins_data %>%
  filter(date_egg< "2007-11-10")
penguin_2007_11_10 %>%
  kbl(caption = "penguin with date_egg before '2007-11-10'") %>%
   kable_material(c("striped", "hover"))
```

```{python, Dot = 3, part = "Result", echo = F, eval = T}
penguins_data [penguins_data.individual_id == "N1A2" ]

penguins_data [penguins_data.date_egg < "2007-11-10" ]
```

<!-- Dot 4, lang: r ------------------------------------------------>
```{block, Dot = 4, part = "Instruction", lang = "r"}
Combining logical operators like `&` (and) and `|` (or) makes it possible to
apply multiple conditions on data frame rows.  
In R language , `!` operator is used as `not`.  
  
Using `%in%` is another way to apply multiple conditions on data frame rows.
```

<!-- Dot 4, lang: python ------------------------------------------------>
```{block, Dot = 4, part = "Instruction", lang = "python"}
Combining logical operators like `&` (and) and `|` (or) makes it possible to
apply multiple conditions on data frame rows.  
In python language , `~` operator is used  for `not` logic in filtering.  
  
`isin` method is another way that helps us to apply multiple conditions for row filtering.    
For example , `df[df.col_1 isin list1]` selects rows that their `col_1` exists
in `list1`.   
```

```{r, Dot = 4, part = "Code", echo = T, eval = F, }
multiple_conditions <- penguins_data %>%
  filter(!body_mass_g < 2800 & sex == "FEMALE")


IDs = c("N2N1" , "N2A2" , "N5A1")

IDs_penguins <- penguins_data %>%
  filter(individual_id %in% IDs)
```

```{python, Dot = 4, part = "Code", echo = T, eval = F, }
penguins_data [~(penguins_data.body_mass_g_ > 2800) & (penguins_data.sex == "FEMALE" )]

IDs = [ "N2N1" , "N2A2" , "N5A1" ]

penguins_data [penguins_data.individual_id.isin(IDs) ]
```

```{r, Dot = 4, part = "Result", echo = F, eval = T}
multiple_conditions <- penguins_data %>%
  filter((body_mass_g < 2800 & sex == "FEMALE" ) | !body_mass_g < 6200)

multiple_conditions %>%
   kbl(caption = "female penguins with body_mass equal to or more than 2800") %>%
   kable_material(c("striped", "hover"))


IDs = c("N2N1" , "N2A2" , "N5A1")

IDs_penguins <- penguins_data %>%
  filter(individual_id %in% IDs)
IDs_penguins %>%
   kbl(caption = "penguins with IDs listed in vector 'IDs'") %>%
   kable_material(c("striped", "hover"))
```

```{python, Dot = 4, part = "Result", echo = F, eval = T}
penguins_data [~(penguins_data.body_mass_g_ > 2800) & (penguins_data.sex == "FEMALE" )]


IDs = [ "N2N1" , "N2A2" , "N5A1" ]

penguins_data [penguins_data.individual_id.isin(IDs) ]
```

<!-- Dot 5, lang: r ------------------------------------------------>
```{block, Dot = 5, part = "Instruction", lang = "r"}
To access a n rows with largest (or smallest) values in a column ,
you should sort data frame based on that column using `arrange('col_name')` function.   
For sorting in descending order , use `arrange(desc('col_name'))`.    
Then you can select k first rows using `top_n(k)`.  
```
<!-- Dot 5, lang: python ------------------------------------------------>
```{block, Dot = 5, part = "Instruction", lang = "python"}
To access n rows with largest (or smallest) values in column 'A', we can use 
`df.nlargest(n , 'A')` (`df.nsmallest(n , 'A')`).  
For exeample , this code returns 2 penguins the highest   
`body-mass-g`.
```

```{r, Dot = 5, part = "Code", echo = T, eval = F, }
before_2007_11_10 <- penguins_data %>%
  filter(date_egg < "2007-11-10")

ordered <- before_2007_11_10 %>%
  arrange(desc(body_mass_g)) %>%
  top_n(2)
```

```{python, Dot = 5, part = "Code", echo = T, eval = F, }
penguins_data.nlargest(2 , 'body_mass_g_')
```

```{r, Dot = 5, part = "Result", echo = F, eval = T}
before_2007_11_10 <- penguins_data %>%
  filter(date_egg < "2007-11-10")

ordered <- before_2007_11_10 %>%
  arrange(desc(body_mass_g)) %>%
  top_n(2)

ordered %>%
  kbl(caption = "2 penguins with largest body_mass") %>%
   kable_material(c("striped", "hover"))
```

```{python, Dot = 5, part = "Result", echo = F, eval = T}
penguins_data.nlargest(2 , 'body_mass_g_')
```

<!-- Dot 6, lang: r ------------------------------------------------>
```{block, Dot = 6, part = "Instruction", lang = "r"}
We can use `row_number()` to filter rows based on their indices.  
`slice()` function can be used as well.
```
<!-- Dot 6, lang: python ------------------------------------------------>
```{block, Dot = 6, part = "Instruction", lang = "python"}
We can use `iloc` and `loc` methods for selecting rows based on index and lable:  
*`iloc` : select row (or column) , based on `index`.  
*`loc` : select row (or column ) , based on `lable`.  
```

```{r, Dot = 6, part = "Code", echo = T, eval = F, }
row_1_2_5 <- penguins_data %>%
     filter(row_number() %in% c(1,2,5))
     
first_5_rows <- penguins_data %>%
  slice(1:5)
```

```{python, Dot = 6, part = "Code", echo = T, eval = F, }
#access rows with indices 0 , 1 and 2:

penguins_data.iloc[0:3 , :]

first_5_rows = penguins_data.head(5)

#update data frame's indices to illustrate how 'loc' works:
first_5_rows.index = ['a' , 'b' , 'c' , 'd' , 'e']

first_5_rows.loc['a' : 'c' , :]
```

```{r, Dot = 6, part = "Result", echo = F, eval = T}
row_1_2_5 <- penguins_data %>%
     filter(row_number() %in% c(1,2,5))
     
first_5_rows <- penguins_data %>%
  slice(1:5)

row_1_2_5 %>%
   kbl(caption = "select first, second and fifth row of penguins_data ") %>%
   kable_material(c("striped", "hover"))

first_5_rows %>% 
   kbl(caption = "first 5 rows from  penguins_data") %>%
   kable_material(c("striped", "hover"))
```

```{python, Dot = 6, part = "Result", echo = F, eval = T}
#access rows with indices 0 , 1 and 2:

penguins_data.iloc[0:3 , :]

first_5_rows = penguins_data.head(5)

#update data frame's indices to illustrate how 'loc' works:
first_5_rows.index = ['a' , 'b' , 'c' , 'd' , 'e']

first_5_rows.loc['a' : 'c' , :]
```

<!-- Dot 7, lang: r ------------------------------------------------>
```{block, Dot = 7, part = "Instruction", lang = "r"}
`sqldf` package has a function , named `sqldf()` that Provides an easy way to perform SQL selects on R data frames.  
  
We can pass selecting conditions as string.
```
<!-- Dot 6, lang: python ------------------------------------------------>
```{block, Dot = 7, part = "Instruction", lang = "python"}
With `df.query()` , we can pass filtering conditions as string.
```

```{r, Dot = 7, part = "Code", echo = T, eval = F, }
library(sqldf)
selected_penguins <- sqldf("select * from penguins_data where body_mass_g < 3000 and date_egg < '2007-11-12'")
```

```{python, Dot = 7, part = "Code", echo = T, eval = F, }
penguins_data.query('body_mass_g_ < 3000 and date_egg < "2007-11-12"')
```

```{r, Dot = 7, part = "Result", echo = F, eval = T}
library(sqldf)
selected_penguins <- sqldf("select * from penguins_data where body_mass_g < 3000 and date_egg < '2007-11-12'")

selected_penguins %>%
  kbl(caption = "penguins wigh body_mass less than 3000 and date_egg before 2007-11-12 ") %>%
   kable_material(c("striped", "hover"))
```

```{python, Dot = 7, part = "Result", echo = F, eval = T}
penguins_data.query('body_mass_g_ < 3000 and date_egg < "2007-11-12"')
```

<!-- Dot 8, lang: r ------------------------------------------------>
```{block, Dot = 8, part = "Instruction", lang = "r"}
Suppose that we want to filter penguins which their "individual_id" contains
`2A`. For this purpose , we can use `str_detect(string , pattern)` from
`stringr` package.  
  
We can also use `regex` , which is a powerful tool for pattern matching.
For example,we can use regex to filter penguins with individual_id that starts
with `N1A`.  
```
<!-- Dot 8, lang: python ------------------------------------------------>
```{block, Dot = 8, part = "Instruction", lang = "python"}
`pandas` library also works well with textual data.So , we can filter data frame row based on strings using `str accessor` methods like `str.startswith('A')` and `str.contains('A')`.  
  
We can also filter data frame rows with `regex` , using `str.match(pattern)` method.
```

```{r, Dot = 8, part = "Code", echo = T, eval = F, }
library(stringr)
contains_2A <- penguins_data %>%
  filter(str_detect(individual_id , "2A"))


starts_with_N1A <- penguins_data %>%
  filter(str_detect(individual_id , "^N1A"))
```

```{python, Dot = 8, part = "Code", echo = T, eval = F, }
penguins_data [penguins_data.individual_id.str.contains('2A')]

penguins_data [penguins_data.individual_id.str.startswith('N1A')]

penguins_data[penguins_data.individual_id.str.match('..1A.')]
```

```{r, Dot = 8, part = "Result", echo = F, eval = T}
library(stringr)
contains_2A <- penguins_data %>%
  filter(str_detect(individual_id , "2A"))


starts_with_N1A <- penguins_data %>%
  filter(str_detect(individual_id , "^N1A"))

contains_2A %>%
  kbl(caption = "penguins that their indivilual_id contains '2A' ") %>%
   kable_material(c("striped", "hover"))

starts_with_N1A %>%
kbl(caption = "penguins that their individual_id starts with 'N1A' ") %>%
   kable_material(c("striped", "hover"))  
```

```{python, Dot = 8, part = "Result", echo = F, eval = T}
penguins_data[penguins_data.individual_id.str.contains('2A')]

penguins_data [penguins_data.individual_id.str.startswith('N1A')]

penguins_data[penguins_data.individual_id.str.match('..1A.')]
```
